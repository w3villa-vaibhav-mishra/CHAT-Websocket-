{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachListeners = void 0;\nvar socket_io_1 = require(\"./socket-io\");\nvar heartbeat_1 = require(\"./heartbeat\");\nvar constants_1 = require(\"./constants\");\nvar util_1 = require(\"./util\");\nvar bindMessageHandler = function (webSocketInstance, optionsRef, setLastMessage, lastMessageTime) {\n  webSocketInstance.onmessage = function (message) {\n    var _a;\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n    if (typeof (lastMessageTime === null || lastMessageTime === void 0 ? void 0 : lastMessageTime.current) === 'number') {\n      lastMessageTime.current = Date.now();\n    }\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n    if (optionsRef.current.heartbeat && typeof optionsRef.current.heartbeat !== \"boolean\" && ((_a = optionsRef.current.heartbeat) === null || _a === void 0 ? void 0 : _a.returnMessage) === message.data) {\n      return;\n    }\n    setLastMessage(message);\n  };\n};\nvar bindOpenHandler = function (webSocketInstance, optionsRef, setReadyState, reconnectCount, lastMessageTime) {\n  webSocketInstance.onopen = function (event) {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(constants_1.ReadyState.OPEN);\n    //start heart beat here\n    if (optionsRef.current.heartbeat && webSocketInstance instanceof WebSocket) {\n      var heartbeatOptions = typeof optionsRef.current.heartbeat === \"boolean\" ? undefined : optionsRef.current.heartbeat;\n      lastMessageTime.current = Date.now();\n      (0, heartbeat_1.heartbeat)(webSocketInstance, lastMessageTime, heartbeatOptions);\n    }\n  };\n};\nvar bindCloseHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return function () {};\n  }\n  (0, util_1.assertIsWebSocket)(webSocketInstance, optionsRef.current.skipAssert);\n  var reconnectTimeout;\n  webSocketInstance.onclose = function (event) {\n    var _a;\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(constants_1.ReadyState.CLOSED);\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      var reconnectAttempts = (_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n      if (reconnectCount.current < reconnectAttempts) {\n        var nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ? optionsRef.current.reconnectInterval(reconnectCount.current) : optionsRef.current.reconnectInterval;\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \".concat(reconnectAttempts, \" exceeded\"));\n      }\n    }\n  };\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\nvar bindErrorHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  var reconnectTimeout;\n  webSocketInstance.onerror = function (error) {\n    var _a;\n    optionsRef.current.onError && optionsRef.current.onError(error);\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose(__assign(__assign({}, error), {\n        code: 1006,\n        reason: \"An error occurred with the EventSource: \".concat(error),\n        wasClean: false\n      }));\n      setReadyState(constants_1.ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < ((_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT)) {\n        var nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ? optionsRef.current.reconnectInterval(reconnectCount.current) : optionsRef.current.reconnectInterval;\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \".concat(optionsRef.current.reconnectAttempts, \" exceeded\"));\n      }\n    }\n  };\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\nvar attachListeners = function (webSocketInstance, setters, optionsRef, reconnect, reconnectCount, lastMessageTime, sendMessage) {\n  var setLastMessage = setters.setLastMessage,\n    setReadyState = setters.setReadyState;\n  var interval;\n  var cancelReconnectOnClose;\n  var cancelReconnectOnError;\n  if (optionsRef.current.fromSocketIO) {\n    interval = (0, socket_io_1.setUpSocketIOPing)(sendMessage);\n  }\n  bindMessageHandler(webSocketInstance, optionsRef, setLastMessage, lastMessageTime);\n  bindOpenHandler(webSocketInstance, optionsRef, setReadyState, reconnectCount, lastMessageTime);\n  cancelReconnectOnClose = bindCloseHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  cancelReconnectOnError = bindErrorHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  return function () {\n    setReadyState(constants_1.ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};\nexports.attachListeners = attachListeners;","map":{"version":3,"names":["socket_io_1","require","heartbeat_1","constants_1","util_1","bindMessageHandler","webSocketInstance","optionsRef","setLastMessage","lastMessageTime","onmessage","message","current","onMessage","Date","now","filter","heartbeat","_a","returnMessage","data","bindOpenHandler","setReadyState","reconnectCount","onopen","event","onOpen","ReadyState","OPEN","WebSocket","heartbeatOptions","undefined","bindCloseHandler","reconnect","isEventSourceSupported","EventSource","assertIsWebSocket","skipAssert","reconnectTimeout","onclose","onClose","CLOSED","shouldReconnect","reconnectAttempts","DEFAULT_RECONNECT_LIMIT","nextReconnectInterval","reconnectInterval","window","setTimeout","DEFAULT_RECONNECT_INTERVAL_MS","onReconnectStop","console","warn","concat","clearTimeout","bindErrorHandler","onerror","error","onError","__assign","code","reason","wasClean","close","retryOnError","attachListeners","setters","sendMessage","interval","cancelReconnectOnClose","cancelReconnectOnError","fromSocketIO","setUpSocketIOPing","CLOSING","clearInterval","exports"],"sources":["/home/vaibav/project/chat/frontend/node_modules/react-use-websocket/src/lib/attach-listener.ts"],"sourcesContent":["import { MutableRefObject } from 'react';\nimport { setUpSocketIOPing } from './socket-io';\nimport { heartbeat } from './heartbeat';\nimport {\n  DEFAULT_RECONNECT_LIMIT,\n  DEFAULT_RECONNECT_INTERVAL_MS,\n  ReadyState,\n  isEventSourceSupported,\n} from './constants';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { assertIsWebSocket } from './util';\n\nexport interface Setters {\n  setLastMessage: (message: WebSocketEventMap['message']) => void;\n  setReadyState: (readyState: ReadyState) => void;\n}\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setLastMessage: Setters['setLastMessage'],\n  lastMessageTime: MutableRefObject<number>,\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n\n    if (typeof lastMessageTime?.current === 'number') {\n      lastMessageTime.current = Date.now();\n    }\n\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n    if (\n      optionsRef.current.heartbeat &&\n      typeof optionsRef.current.heartbeat !== \"boolean\" &&\n      optionsRef.current.heartbeat?.returnMessage === message.data\n    ) {\n      return;\n    }\n\n    setLastMessage(message);\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnectCount: MutableRefObject<number>,\n  lastMessageTime: MutableRefObject<number>,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(ReadyState.OPEN);\n    //start heart beat here\n    if (optionsRef.current.heartbeat && webSocketInstance instanceof WebSocket) {\n      const heartbeatOptions =\n        typeof optionsRef.current.heartbeat === \"boolean\"\n          ? undefined\n          : optionsRef.current.heartbeat;\n      lastMessageTime.current = Date.now();\n      heartbeat(webSocketInstance, lastMessageTime, heartbeatOptions);\n    }\n\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return () => { };\n  }\n  assertIsWebSocket(webSocketInstance, optionsRef.current.skipAssert);\n  let reconnectTimeout: number;\n\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(ReadyState.CLOSED);\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      const reconnectAttempts = optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n      if (reconnectCount.current < reconnectAttempts) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  let reconnectTimeout: number;\n\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    optionsRef.current.onError && optionsRef.current.onError(error);\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose({\n        ...error,\n        code: 1006,\n        reason: `An error occurred with the EventSource: ${error}`,\n        wasClean: false,\n      });\n\n      setReadyState(ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n\n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < (optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT)) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts as number);\n        console.warn(`Max reconnect attempts of ${optionsRef.current.reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nexport const attachListeners = (\n  webSocketInstance: WebSocketLike,\n  setters: Setters,\n  optionsRef: MutableRefObject<Options>,\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n  lastMessageTime: MutableRefObject<number>,\n  sendMessage: SendMessage\n): (() => void) => {\n  const { setLastMessage, setReadyState } = setters;\n\n  let interval: number;\n  let cancelReconnectOnClose: () => void;\n  let cancelReconnectOnError: () => void;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(\n    webSocketInstance,\n    optionsRef,\n    setLastMessage,\n    lastMessageTime\n  );\n\n  bindOpenHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnectCount,\n    lastMessageTime,\n  );\n\n  cancelReconnectOnClose = bindCloseHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  cancelReconnectOnError = bindErrorHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  return () => {\n    setReadyState(ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}