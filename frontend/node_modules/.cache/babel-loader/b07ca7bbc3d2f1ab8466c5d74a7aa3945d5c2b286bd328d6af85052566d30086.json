{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachSharedListeners = void 0;\nvar globals_1 = require(\"./globals\");\nvar constants_1 = require(\"./constants\");\nvar manage_subscribers_1 = require(\"./manage-subscribers\");\nvar socket_io_1 = require(\"./socket-io\");\nvar heartbeat_1 = require(\"./heartbeat\");\nvar bindMessageHandler = function (webSocketInstance, url, heartbeatOptions) {\n  webSocketInstance.onmessage = function (message) {\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      var _a;\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n      if (typeof ((_a = subscriber === null || subscriber === void 0 ? void 0 : subscriber.lastMessageTime) === null || _a === void 0 ? void 0 : _a.current) === 'number') {\n        subscriber.lastMessageTime.current = Date.now();\n      }\n      if (typeof subscriber.optionsRef.current.filter === 'function' && subscriber.optionsRef.current.filter(message) !== true) {\n        return;\n      }\n      if (heartbeatOptions && typeof heartbeatOptions !== \"boolean\" && (heartbeatOptions === null || heartbeatOptions === void 0 ? void 0 : heartbeatOptions.returnMessage) === message.data) return;\n      subscriber.setLastMessage(message);\n    });\n  };\n};\nvar bindOpenHandler = function (webSocketInstance, url, heartbeatOptions) {\n  webSocketInstance.onopen = function (event) {\n    var subscribers = (0, manage_subscribers_1.getSubscribers)(url);\n    subscribers.forEach(function (subscriber) {\n      subscriber.reconnectCount.current = 0;\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n      subscriber.setReadyState(constants_1.ReadyState.OPEN);\n      var onMessageCb;\n      if (heartbeatOptions && webSocketInstance instanceof WebSocket) {\n        subscriber.lastMessageTime.current = Date.now();\n      }\n    });\n    if (heartbeatOptions && webSocketInstance instanceof WebSocket) {\n      (0, heartbeat_1.heartbeat)(webSocketInstance, subscribers.map(function (subscriber) {\n        return subscriber.lastMessageTime;\n      }), typeof heartbeatOptions === 'boolean' ? undefined : heartbeatOptions);\n    }\n  };\n};\nvar bindCloseHandler = function (webSocketInstance, url) {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = function (event) {\n      (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      });\n      delete globals_1.sharedWebSockets[url];\n      (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n        var _a;\n        if (subscriber.optionsRef.current.shouldReconnect && subscriber.optionsRef.current.shouldReconnect(event)) {\n          var reconnectAttempts = (_a = subscriber.optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            var nextReconnectInterval = typeof subscriber.optionsRef.current.reconnectInterval === 'function' ? subscriber.optionsRef.current.reconnectInterval(subscriber.reconnectCount.current) : subscriber.optionsRef.current.reconnectInterval;\n            setTimeout(function () {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts);\n            console.warn(\"Max reconnect attempts of \".concat(reconnectAttempts, \" exceeded\"));\n          }\n        }\n      });\n    };\n  }\n};\nvar bindErrorHandler = function (webSocketInstance, url) {\n  webSocketInstance.onerror = function (error) {\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n      if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose(__assign(__assign({}, error), {\n          code: 1006,\n          reason: \"An error occurred with the EventSource: \".concat(error),\n          wasClean: false\n        }));\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      }\n    });\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\nvar attachSharedListeners = function (webSocketInstance, url, optionsRef, sendMessage) {\n  var interval;\n  if (optionsRef.current.fromSocketIO) {\n    interval = (0, socket_io_1.setUpSocketIOPing)(sendMessage);\n  }\n  bindMessageHandler(webSocketInstance, url, optionsRef.current.heartbeat);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url, optionsRef.current.heartbeat);\n  bindErrorHandler(webSocketInstance, url);\n  return function () {\n    if (interval) clearInterval(interval);\n  };\n};\nexports.attachSharedListeners = attachSharedListeners;","map":{"version":3,"names":["globals_1","require","constants_1","manage_subscribers_1","socket_io_1","heartbeat_1","bindMessageHandler","webSocketInstance","url","heartbeatOptions","onmessage","message","getSubscribers","forEach","subscriber","optionsRef","current","onMessage","_a","lastMessageTime","Date","now","filter","returnMessage","data","setLastMessage","bindOpenHandler","onopen","event","subscribers","reconnectCount","onOpen","setReadyState","ReadyState","OPEN","onMessageCb","WebSocket","heartbeat","map","undefined","bindCloseHandler","onclose","onClose","CLOSED","sharedWebSockets","shouldReconnect","reconnectAttempts","DEFAULT_RECONNECT_LIMIT","nextReconnectInterval","reconnectInterval","setTimeout","reconnect","DEFAULT_RECONNECT_INTERVAL_MS","onReconnectStop","console","warn","concat","bindErrorHandler","onerror","error","onError","isEventSourceSupported","EventSource","__assign","code","reason","wasClean","close","attachSharedListeners","sendMessage","interval","fromSocketIO","setUpSocketIOPing","clearInterval","exports"],"sources":["/home/vaibav/project/chat/frontend/node_modules/react-use-websocket/src/lib/attach-shared-listeners.ts"],"sourcesContent":["import { sharedWebSockets } from './globals';\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState, isEventSourceSupported } from './constants';\nimport { getSubscribers } from './manage-subscribers';\nimport { MutableRefObject } from 'react';\nimport { HeartbeatOptions, Options, SendMessage, WebSocketLike } from './types';\nimport { setUpSocketIOPing } from './socket-io';\nimport { heartbeat } from './heartbeat';\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  heartbeatOptions?: boolean | HeartbeatOptions\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n\n      if (typeof subscriber?.lastMessageTime?.current === 'number') {\n        subscriber.lastMessageTime.current = Date.now();\n      }\n\n      if (\n        typeof subscriber.optionsRef.current.filter === 'function' &&\n        subscriber.optionsRef.current.filter(message) !== true\n      ) {\n        return;\n      }\n\n      if (\n        heartbeatOptions &&\n        typeof heartbeatOptions !== \"boolean\" &&\n        heartbeatOptions?.returnMessage === message.data\n      )\n        return;\n\n      subscriber.setLastMessage(message);\n    });\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  heartbeatOptions?: boolean | HeartbeatOptions\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    const subscribers = getSubscribers(url);\n    subscribers.forEach(subscriber => {\n      subscriber.reconnectCount.current = 0;\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n\n      subscriber.setReadyState(ReadyState.OPEN);\n\n      let onMessageCb: () => void;\n\n      if (heartbeatOptions && webSocketInstance instanceof WebSocket) {\n        subscriber.lastMessageTime.current = Date.now();\n      }\n    });\n    if (heartbeatOptions && webSocketInstance instanceof WebSocket) {\n      heartbeat(webSocketInstance, subscribers.map(subscriber => subscriber.lastMessageTime), typeof heartbeatOptions === 'boolean' ? undefined : heartbeatOptions,);\n    }\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n      getSubscribers(url).forEach(subscriber => {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n\n        subscriber.setReadyState(ReadyState.CLOSED);\n      });\n\n      delete sharedWebSockets[url];\n\n      getSubscribers(url).forEach(subscriber => {\n        if (\n          subscriber.optionsRef.current.shouldReconnect &&\n          subscriber.optionsRef.current.shouldReconnect(event)\n        ) {\n          const reconnectAttempts = subscriber.optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            const nextReconnectInterval = typeof subscriber.optionsRef.current.reconnectInterval === 'function' ?\n              subscriber.optionsRef.current.reconnectInterval(subscriber.reconnectCount.current) :\n              subscriber.optionsRef.current.reconnectInterval;\n\n            setTimeout(() => {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts as number);\n            console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n          }\n        }\n      });\n    };\n  }\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n      if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose({\n          ...error,\n          code: 1006,\n          reason: `An error occurred with the EventSource: ${error}`,\n          wasClean: false,\n        });\n\n        subscriber.setReadyState(ReadyState.CLOSED);\n      }\n    });\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\n\nexport const attachSharedListeners = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  optionsRef: MutableRefObject<Options>,\n  sendMessage: SendMessage,\n) => {\n  let interval: number;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, url, optionsRef.current.heartbeat);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url, optionsRef.current.heartbeat);\n  bindErrorHandler(webSocketInstance, url);\n\n  return () => {\n    if (interval) clearInterval(interval);\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}